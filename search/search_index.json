{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Your React components should respond to AI the same way they respond to users \u2014 no special wiring, no rebuilds. The idea Your React app's components define its business layer \u2014 what data matters, what states are valid, how the product behaves. reactAI embeds AI agents directly into that layer. Instead of an agent running outside your app, guessing at the UI by clicking buttons and reading the screen, it becomes a native participant \u2014 driving your components through the interface their author designed. // Without reactAI: custom wiring per component const res = await myAiEndpoint ( prompt ) setUsername ( res . username ) setLanguage ( res . language ) // With reactAI: describe once, let AI drive const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' , }) Two ways to make a component AI-controllable Hook \u2014 state inside a component The simplest path. Replace useState with useStateWithAi , give it a description, attach the ref. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' } ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> </ div > ) } No scanner, no annotation. The AI can now update username and language by natural language. HOC \u2014 wrap an existing component For components you can't modify internally \u2014 from a design system, a library, or a legacy codebase. Annotate the props interface, run the scanner once, wrap the component. import { reactAI } from '@bnbarak/reactai/react' /** * @reactAi * @key demo-card * @description A product card with a title and CTA. */ interface DemoCardProps { /** @reactAi Headline text */ title : string onButtonClick : () => void // not annotated \u2014 never AI-writable } export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card' }) The AI can update title . It can never touch onButtonClick \u2014 function props are explicitly excluded. The scanner reads your TypeScript source at build time and extracts the annotation into a registry.json file \u2014 the server loads it at startup so the AI knows which components exist and what it is allowed to change. See the Scanner \u2192 for the full annotation syntax and CLI. Get started Quickstart \u2192 \u2014 up and running in 5 minutes.","title":"Home"},{"location":"#the-idea","text":"Your React app's components define its business layer \u2014 what data matters, what states are valid, how the product behaves. reactAI embeds AI agents directly into that layer. Instead of an agent running outside your app, guessing at the UI by clicking buttons and reading the screen, it becomes a native participant \u2014 driving your components through the interface their author designed. // Without reactAI: custom wiring per component const res = await myAiEndpoint ( prompt ) setUsername ( res . username ) setLanguage ( res . language ) // With reactAI: describe once, let AI drive const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' , })","title":"The idea"},{"location":"#two-ways-to-make-a-component-ai-controllable","text":"","title":"Two ways to make a component AI-controllable"},{"location":"#hook-state-inside-a-component","text":"The simplest path. Replace useState with useStateWithAi , give it a description, attach the ref. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' } ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> </ div > ) } No scanner, no annotation. The AI can now update username and language by natural language.","title":"Hook \u2014 state inside a component"},{"location":"#hoc-wrap-an-existing-component","text":"For components you can't modify internally \u2014 from a design system, a library, or a legacy codebase. Annotate the props interface, run the scanner once, wrap the component. import { reactAI } from '@bnbarak/reactai/react' /** * @reactAi * @key demo-card * @description A product card with a title and CTA. */ interface DemoCardProps { /** @reactAi Headline text */ title : string onButtonClick : () => void // not annotated \u2014 never AI-writable } export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card' }) The AI can update title . It can never touch onButtonClick \u2014 function props are explicitly excluded. The scanner reads your TypeScript source at build time and extracts the annotation into a registry.json file \u2014 the server loads it at startup so the AI knows which components exist and what it is allowed to change. See the Scanner \u2192 for the full annotation syntax and CLI.","title":"HOC \u2014 wrap an existing component"},{"location":"#get-started","text":"Quickstart \u2192 \u2014 up and running in 5 minutes.","title":"Get started"},{"location":"api/","text":"Client \u2014 @bnbarak/reactai/react <SessionProvider> Wrap your app once at the root. Creates a session with the server on mount, opens the SSE connection, and makes sessionId and serverUrl available to all hooks below it. import { SessionProvider } from '@bnbarak/reactai/react' < SessionProvider serverUrl = \"http://localhost:3001/api\" > < App /> </ SessionProvider > Props Prop Type Default Description serverUrl string \"http://localhost:3001/api\" Base URL of the reactAI router mount path children ReactNode \u2014 Behaviour On mount: POST /sessions \u2192 receives sessionId \u2192 opens GET /sse/:sessionId Retries session creation up to 10 times with 1.5s backoff if the server is unavailable On unmount: closes the SSE connection useStateWithAi(description, initialState, context?) Drop-in replacement for useState . The component registers itself as AI-controllable and subscribes to patches from the server. const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, ) Parameters Parameter Type Description description string Human-readable description of what this component represents. Becomes the component key. initialState T extends Record<string, unknown> Initial state values. All top-level keys are automatically AI-writable. context Record<string, unknown> Optional. Enum options, ranges, or labels for props. Passed to the AI as allowed values. Returns [T, Dispatch<SetStateAction<T>>, RefObject<HTMLElement | null>] Type Description state T Current state, identical to useState setState Dispatch<SetStateAction<T>> Standard React state setter aiRef RefObject<HTMLElement> Attach to your root element. Sets data-ai-id for the accessibility tree snapshot. Key derivation The description is slugified to produce a stable key: \"User profile settings\" \u2192 \"user-profile-settings\" This key identifies the component in patches and SSE events. Singleton behaviour Two components with the same description share one AI key. All instances update simultaneously when a patch arrives for that key. Use this intentionally when multiple parts of the UI represent the same logical state (e.g. a username in a header and in a settings form). What is AI-writable All keys present in initialState are AI-writable. There is no annotation step \u2014 the hook derives aiWritableProps from Object.keys(initialState) at mount time. No scanner required useStateWithAi is fully self-describing. It sends its own description, writable props, current state, and context with every prompt. No registry.json needed. reactAI(Component, options) Higher-order component that makes a prop-based component AI-controllable. The AI can override specific props independently per mounted instance. import { reactAI } from '@bnbarak/reactai/react' export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and CTA' , }) // Use exactly like the original component < AiCard title = \"Hello\" onButtonClick = { handleClick } /> Parameters Parameter Type Description Component React.ComponentType<P> The component to wrap options.key string Stable identifier. Must match the @key annotation in the props interface. options.description string What this component represents. Sent to the AI for targeting. Returns React.ComponentType<P> The returned component behaves identically to the original. Base props are always passed through. The AI can only override props listed in aiWritableProps from registry.json \u2014 function props are never included. Per-instance identity Each mount of the wrapped component gets a random stable instanceId via crypto.randomUUID() . Multiple cards in a list are independently addressable \u2014 the AI can target \"the second card\" or \"the card with title X\". DOM wrapper The HOC renders a display: contents <div> with data-ai-id and data-ai-key attributes around the inner component. This wrapper is invisible to layout. Requires scanner The HOC reads aiWritableProps from registry.json at runtime. The component's props interface must be annotated with @reactAi and scanned before the server starts. See Architecture \u2192 Scanner . useAiMarker(name, value) Registers a named ambient value in the marker registry. The AI receives all current markers with every prompt \u2014 use this to tell the agent what page, mode, or context is active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } Parameters Parameter Type Description name string Marker key value unknown Any serialisable value \u2014 string, number, object The marker is registered on mount and removed on unmount. Updates when value changes. Why this matters Without markers, the AI only sees the components currently on screen. Markers let you inject context that isn't tied to any specific component: useAiMarker ( 'activePage' , 'kanban' ) useAiMarker ( 'userRole' , 'admin' ) useAiMarker ( 'featureFlags' , { darkMode : true , betaCheckout : false }) The AI can then reason: \"the user asked to update the kanban board \u2014 I can see activePage: kanban , so I'll target the kanban components.\" useSession() Returns the current session context. Use this to read sessionId and serverUrl when building a custom prompt sender. import { useSession } from '@bnbarak/reactai/react' const { sessionId , serverUrl } = useSession () await fetch ( ` ${ serverUrl } /ai/prompt` , { method : 'POST' , headers : { 'Content-Type' : 'application/json' }, body : JSON.stringify ({ sessionId , prompt , snapshot }), }) Returns Type Description sessionId string \\| null null until the session is created (async on mount) serverUrl string The URL passed to SessionProvider snapshotRegistry Module singleton. Holds the current state of all mounted AI-controllable components. Call getAll() to build the snapshot payload for a prompt request. import { snapshotRegistry } from '@bnbarak/reactai/react' const snapshot = snapshotRegistry . getAll () await fetch ( ` ${ serverUrl } /ai/prompt` , { method : 'POST' , body : JSON.stringify ({ sessionId , prompt , snapshot }), }) Methods Method Signature Description getAll() () => MountedInstance[] Returns all currently mounted AI-controllable instances set() (instanceId, entry) => void Called internally by hooks \u2014 do not call directly remove() (instanceId) => void Called internally on unmount \u2014 do not call directly Server \u2014 @bnbarak/reactai/server createReactAiRouter(options?) Creates an Express router with all reactAI routes. Mount it at any path in your existing app. import { createReactAiRouter } from '@bnbarak/reactai/server' app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) Options Option Type Default Description registryPath string \u2014 Path to registry.json . Loaded synchronously at startup. Throws if the file is missing. manifests ComponentManifest[] \u2014 Provide pre-loaded manifests directly instead of a file path. Takes precedence over registryPath . sdk AiSdkLike \u2014 LLM SDK instance. If omitted, the POST /ai/prompt route is not registered. Fail-fast on missing registry If registryPath is set and the file doesn't exist, createReactAiRouter throws immediately at startup. Run npm run scan before starting the server. Routes All paths are relative to the router mount point. POST /sessions Creates a new session. Called automatically by SessionProvider on mount. Response \u2014 201 { \"sessionId\" : \"550e8400-e29b-41d4-a716-446655440000\" } GET /sse/:sessionId Opens a long-lived SSE stream for the given session. Called automatically by the bridge after session creation. The bridge reconnects automatically on connection loss (1s backoff). Events \u2014 newline-delimited JSON: data : { \"type\" : \"patch\" , \"key\" : \"demo-card\" , \"instanceId\" : \"abc123\" , \"patch\" :{ \"title\" : \"New title\" }} data : { \"type\" : \"snapshot\" , \"key\" : \"user-profile\" , \"instanceId\" : \"user-profile\" , \"state\" :{ \"username\" : \"alice\" }} data : { \"type\" : \"error\" , \"message\" : \"Patch validation failed\" } data : { \"type\" : \"ack\" , \"requestId\" : \"req-1\" , \"applied\" : true } SseEvent union type Fields Description patch key , instanceId , patch Merge patch into component state snapshot key , instanceId , state Replace component state entirely error message Server-side error ack requestId , applied Confirmation of a direct patch GET /registry Returns all component manifests from registry.json . Response \u2014 200 [ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ] GET /registry/:key Returns the manifest for a single component. Response \u2014 404 if the key is not found: { \"error\" : \"Component 'unknown-key' not found\" } POST /patches Applies a patch directly \u2014 no LLM involved. Validates the patch against aiWritableProps , then broadcasts via SSE. Request { \"sessionId\" : \"550e8400-...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"abc123\" , \"patch\" : { \"title\" : \"Direct update\" } } Response \u2014 200 { \"applied\" : true } Response \u2014 422 if any patch key is not in aiWritableProps : { \"applied\" : false , \"errors\" : [ \"Prop 'onButtonClick' is not AI-writable for component 'demo-card'\" ] } Response \u2014 404 if sessionId is unknown. POST /ai/prompt Main AI entry point. Accepts a natural language prompt and a snapshot of all currently mounted components. Returns the patch that was applied. Request { \"sessionId\" : \"550e8400-...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ], \"accessibilityTree\" : \"...\" , \"markers\" : { \"activePage\" : \"settings\" }, \"currentUrl\" : \"/settings\" } Field Required Description sessionId \u2713 Active session from POST /sessions prompt \u2713 Natural language instruction snapshot \u2713 MountedInstance[] from snapshotRegistry.getAll() accessibilityTree \u2014 Serialised accessibility tree of the current page. Provides visual context. markers \u2014 Key/value context from useAiMarker calls currentUrl \u2014 Current browser URL Response \u2014 200 { \"target\" : { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" }, \"patch\" : { \"username\" : \"alice\" }, \"applied\" : true , \"isDone\" : true } Field Type Description target { key, instanceId } \\| null The component that was updated patch Record<string, unknown> \\| null The values that were set applied boolean Whether the patch was broadcast via SSE isDone boolean false signals the client to send another turn (multi-step task) errors string[] Present when applied is false When applied is true , the patch is immediately broadcast to the session's SSE stream before the response is sent. Types \u2014 react-ai-core ComponentManifest Static description of a component, produced by the scanner and loaded by the server. interface ComponentManifest { key : string // stable identifier, e.g. \"demo-card\" description : string // what the AI sees when selecting a target filePath : string // source file (informational) aiWritableProps : string [] // props the AI is allowed to set propsJsonSchema : JsonSchema // JSON Schema derived from the TypeScript interface contextSummary? : string // optional extra context injected into the prompt } MountedInstance Live snapshot of one mounted component instance, collected by the bridge and sent with every prompt. interface MountedInstance { key : string // matches ComponentManifest.key instanceId : string // stable per mount (slugified key or UUID) currentProps? : Record < string , unknown > // current state values description? : string // self-describing (useStateWithAi only) aiWritableProps? : string [] // self-describing (useStateWithAi only) context? : Record < string , unknown > // enum options, ranges, etc. } For useStateWithAi , description and aiWritableProps are set by the hook. For reactAI() HOC, they come from registry.json . SseEvent Union type for all events broadcast over the SSE stream. type SseEvent = | { type : 'patch' ; key : string ; instanceId : string ; patch : Record < string , unknown > } | { type : 'snapshot' ; key : string ; instanceId : string ; state : Record < string , unknown > } | { type : 'error' ; message : string } | { type : 'ack' ; requestId : string ; applied : boolean } SdkResult Return type of AiSdkLike.updateFromPrompt . Also the response shape of POST /ai/prompt . interface SdkResult { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean } AiSdkLike Interface the server depends on. Implement this to use any LLM provider. interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < SdkResult > }","title":"API Reference"},{"location":"api/#client-bnbarakreactaireact","text":"","title":"Client \u2014 @bnbarak/reactai/react"},{"location":"api/#sessionprovider","text":"Wrap your app once at the root. Creates a session with the server on mount, opens the SSE connection, and makes sessionId and serverUrl available to all hooks below it. import { SessionProvider } from '@bnbarak/reactai/react' < SessionProvider serverUrl = \"http://localhost:3001/api\" > < App /> </ SessionProvider > Props Prop Type Default Description serverUrl string \"http://localhost:3001/api\" Base URL of the reactAI router mount path children ReactNode \u2014 Behaviour On mount: POST /sessions \u2192 receives sessionId \u2192 opens GET /sse/:sessionId Retries session creation up to 10 times with 1.5s backoff if the server is unavailable On unmount: closes the SSE connection","title":"&lt;SessionProvider&gt;"},{"location":"api/#usestatewithaidescription-initialstate-context","text":"Drop-in replacement for useState . The component registers itself as AI-controllable and subscribes to patches from the server. const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, ) Parameters Parameter Type Description description string Human-readable description of what this component represents. Becomes the component key. initialState T extends Record<string, unknown> Initial state values. All top-level keys are automatically AI-writable. context Record<string, unknown> Optional. Enum options, ranges, or labels for props. Passed to the AI as allowed values. Returns [T, Dispatch<SetStateAction<T>>, RefObject<HTMLElement | null>] Type Description state T Current state, identical to useState setState Dispatch<SetStateAction<T>> Standard React state setter aiRef RefObject<HTMLElement> Attach to your root element. Sets data-ai-id for the accessibility tree snapshot. Key derivation The description is slugified to produce a stable key: \"User profile settings\" \u2192 \"user-profile-settings\" This key identifies the component in patches and SSE events. Singleton behaviour Two components with the same description share one AI key. All instances update simultaneously when a patch arrives for that key. Use this intentionally when multiple parts of the UI represent the same logical state (e.g. a username in a header and in a settings form). What is AI-writable All keys present in initialState are AI-writable. There is no annotation step \u2014 the hook derives aiWritableProps from Object.keys(initialState) at mount time. No scanner required useStateWithAi is fully self-describing. It sends its own description, writable props, current state, and context with every prompt. No registry.json needed.","title":"useStateWithAi(description, initialState, context?)"},{"location":"api/#reactaicomponent-options","text":"Higher-order component that makes a prop-based component AI-controllable. The AI can override specific props independently per mounted instance. import { reactAI } from '@bnbarak/reactai/react' export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and CTA' , }) // Use exactly like the original component < AiCard title = \"Hello\" onButtonClick = { handleClick } /> Parameters Parameter Type Description Component React.ComponentType<P> The component to wrap options.key string Stable identifier. Must match the @key annotation in the props interface. options.description string What this component represents. Sent to the AI for targeting. Returns React.ComponentType<P> The returned component behaves identically to the original. Base props are always passed through. The AI can only override props listed in aiWritableProps from registry.json \u2014 function props are never included. Per-instance identity Each mount of the wrapped component gets a random stable instanceId via crypto.randomUUID() . Multiple cards in a list are independently addressable \u2014 the AI can target \"the second card\" or \"the card with title X\". DOM wrapper The HOC renders a display: contents <div> with data-ai-id and data-ai-key attributes around the inner component. This wrapper is invisible to layout. Requires scanner The HOC reads aiWritableProps from registry.json at runtime. The component's props interface must be annotated with @reactAi and scanned before the server starts. See Architecture \u2192 Scanner .","title":"reactAI(Component, options)"},{"location":"api/#useaimarkername-value","text":"Registers a named ambient value in the marker registry. The AI receives all current markers with every prompt \u2014 use this to tell the agent what page, mode, or context is active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } Parameters Parameter Type Description name string Marker key value unknown Any serialisable value \u2014 string, number, object The marker is registered on mount and removed on unmount. Updates when value changes. Why this matters Without markers, the AI only sees the components currently on screen. Markers let you inject context that isn't tied to any specific component: useAiMarker ( 'activePage' , 'kanban' ) useAiMarker ( 'userRole' , 'admin' ) useAiMarker ( 'featureFlags' , { darkMode : true , betaCheckout : false }) The AI can then reason: \"the user asked to update the kanban board \u2014 I can see activePage: kanban , so I'll target the kanban components.\"","title":"useAiMarker(name, value)"},{"location":"api/#usesession","text":"Returns the current session context. Use this to read sessionId and serverUrl when building a custom prompt sender. import { useSession } from '@bnbarak/reactai/react' const { sessionId , serverUrl } = useSession () await fetch ( ` ${ serverUrl } /ai/prompt` , { method : 'POST' , headers : { 'Content-Type' : 'application/json' }, body : JSON.stringify ({ sessionId , prompt , snapshot }), }) Returns Type Description sessionId string \\| null null until the session is created (async on mount) serverUrl string The URL passed to SessionProvider","title":"useSession()"},{"location":"api/#snapshotregistry","text":"Module singleton. Holds the current state of all mounted AI-controllable components. Call getAll() to build the snapshot payload for a prompt request. import { snapshotRegistry } from '@bnbarak/reactai/react' const snapshot = snapshotRegistry . getAll () await fetch ( ` ${ serverUrl } /ai/prompt` , { method : 'POST' , body : JSON.stringify ({ sessionId , prompt , snapshot }), }) Methods Method Signature Description getAll() () => MountedInstance[] Returns all currently mounted AI-controllable instances set() (instanceId, entry) => void Called internally by hooks \u2014 do not call directly remove() (instanceId) => void Called internally on unmount \u2014 do not call directly","title":"snapshotRegistry"},{"location":"api/#server-bnbarakreactaiserver","text":"","title":"Server \u2014 @bnbarak/reactai/server"},{"location":"api/#createreactairouteroptions","text":"Creates an Express router with all reactAI routes. Mount it at any path in your existing app. import { createReactAiRouter } from '@bnbarak/reactai/server' app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) Options Option Type Default Description registryPath string \u2014 Path to registry.json . Loaded synchronously at startup. Throws if the file is missing. manifests ComponentManifest[] \u2014 Provide pre-loaded manifests directly instead of a file path. Takes precedence over registryPath . sdk AiSdkLike \u2014 LLM SDK instance. If omitted, the POST /ai/prompt route is not registered. Fail-fast on missing registry If registryPath is set and the file doesn't exist, createReactAiRouter throws immediately at startup. Run npm run scan before starting the server.","title":"createReactAiRouter(options?)"},{"location":"api/#routes","text":"All paths are relative to the router mount point.","title":"Routes"},{"location":"api/#post-sessions","text":"Creates a new session. Called automatically by SessionProvider on mount. Response \u2014 201 { \"sessionId\" : \"550e8400-e29b-41d4-a716-446655440000\" }","title":"POST /sessions"},{"location":"api/#get-ssesessionid","text":"Opens a long-lived SSE stream for the given session. Called automatically by the bridge after session creation. The bridge reconnects automatically on connection loss (1s backoff). Events \u2014 newline-delimited JSON: data : { \"type\" : \"patch\" , \"key\" : \"demo-card\" , \"instanceId\" : \"abc123\" , \"patch\" :{ \"title\" : \"New title\" }} data : { \"type\" : \"snapshot\" , \"key\" : \"user-profile\" , \"instanceId\" : \"user-profile\" , \"state\" :{ \"username\" : \"alice\" }} data : { \"type\" : \"error\" , \"message\" : \"Patch validation failed\" } data : { \"type\" : \"ack\" , \"requestId\" : \"req-1\" , \"applied\" : true } SseEvent union type Fields Description patch key , instanceId , patch Merge patch into component state snapshot key , instanceId , state Replace component state entirely error message Server-side error ack requestId , applied Confirmation of a direct patch","title":"GET /sse/:sessionId"},{"location":"api/#get-registry","text":"Returns all component manifests from registry.json . Response \u2014 200 [ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ]","title":"GET /registry"},{"location":"api/#get-registrykey","text":"Returns the manifest for a single component. Response \u2014 404 if the key is not found: { \"error\" : \"Component 'unknown-key' not found\" }","title":"GET /registry/:key"},{"location":"api/#post-patches","text":"Applies a patch directly \u2014 no LLM involved. Validates the patch against aiWritableProps , then broadcasts via SSE. Request { \"sessionId\" : \"550e8400-...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"abc123\" , \"patch\" : { \"title\" : \"Direct update\" } } Response \u2014 200 { \"applied\" : true } Response \u2014 422 if any patch key is not in aiWritableProps : { \"applied\" : false , \"errors\" : [ \"Prop 'onButtonClick' is not AI-writable for component 'demo-card'\" ] } Response \u2014 404 if sessionId is unknown.","title":"POST /patches"},{"location":"api/#post-aiprompt","text":"Main AI entry point. Accepts a natural language prompt and a snapshot of all currently mounted components. Returns the patch that was applied. Request { \"sessionId\" : \"550e8400-...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ], \"accessibilityTree\" : \"...\" , \"markers\" : { \"activePage\" : \"settings\" }, \"currentUrl\" : \"/settings\" } Field Required Description sessionId \u2713 Active session from POST /sessions prompt \u2713 Natural language instruction snapshot \u2713 MountedInstance[] from snapshotRegistry.getAll() accessibilityTree \u2014 Serialised accessibility tree of the current page. Provides visual context. markers \u2014 Key/value context from useAiMarker calls currentUrl \u2014 Current browser URL Response \u2014 200 { \"target\" : { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" }, \"patch\" : { \"username\" : \"alice\" }, \"applied\" : true , \"isDone\" : true } Field Type Description target { key, instanceId } \\| null The component that was updated patch Record<string, unknown> \\| null The values that were set applied boolean Whether the patch was broadcast via SSE isDone boolean false signals the client to send another turn (multi-step task) errors string[] Present when applied is false When applied is true , the patch is immediately broadcast to the session's SSE stream before the response is sent.","title":"POST /ai/prompt"},{"location":"api/#types-react-ai-core","text":"","title":"Types \u2014 react-ai-core"},{"location":"api/#componentmanifest","text":"Static description of a component, produced by the scanner and loaded by the server. interface ComponentManifest { key : string // stable identifier, e.g. \"demo-card\" description : string // what the AI sees when selecting a target filePath : string // source file (informational) aiWritableProps : string [] // props the AI is allowed to set propsJsonSchema : JsonSchema // JSON Schema derived from the TypeScript interface contextSummary? : string // optional extra context injected into the prompt }","title":"ComponentManifest"},{"location":"api/#mountedinstance","text":"Live snapshot of one mounted component instance, collected by the bridge and sent with every prompt. interface MountedInstance { key : string // matches ComponentManifest.key instanceId : string // stable per mount (slugified key or UUID) currentProps? : Record < string , unknown > // current state values description? : string // self-describing (useStateWithAi only) aiWritableProps? : string [] // self-describing (useStateWithAi only) context? : Record < string , unknown > // enum options, ranges, etc. } For useStateWithAi , description and aiWritableProps are set by the hook. For reactAI() HOC, they come from registry.json .","title":"MountedInstance"},{"location":"api/#sseevent","text":"Union type for all events broadcast over the SSE stream. type SseEvent = | { type : 'patch' ; key : string ; instanceId : string ; patch : Record < string , unknown > } | { type : 'snapshot' ; key : string ; instanceId : string ; state : Record < string , unknown > } | { type : 'error' ; message : string } | { type : 'ack' ; requestId : string ; applied : boolean }","title":"SseEvent"},{"location":"api/#sdkresult","text":"Return type of AiSdkLike.updateFromPrompt . Also the response shape of POST /ai/prompt . interface SdkResult { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean }","title":"SdkResult"},{"location":"api/#aisdklike","text":"Interface the server depends on. Implement this to use any LLM provider. interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < SdkResult > }","title":"AiSdkLike"},{"location":"quickstart/","text":"reactAI connects your React components directly to AI agents. Instead of an agent clicking through your UI like a user, it reads your component state and patches it directly \u2014 the same way React does. You describe what a component represents. The agent figures out which component to update, what values to set, and applies it. Your component re-renders. No DOM interaction, no fragile selectors, no simulated clicks. Get up and running in 5 minutes. Prerequisites Node.js 18+ An existing Express + React app Anthropic API key 1. Install packages npm install @bnbarak/reactai That's it \u2014 one package. Use subpath imports to pull in only what you need: Subpath Who uses it @bnbarak/reactai/react Your React app @bnbarak/reactai/server Your Express server @bnbarak/reactai/scanner Build step (CLI) 2. Scan your components (build step) Add the scan script to your package.json : { \"scripts\" : { \"scan\" : \"npx react-ai-scan src/ ./registry.json\" } } Run it once to generate registry.json : npm run scan Tip Add scan as a pre-build step so the registry stays up to date automatically. 3. Mount the router on your Express server import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 ) 4. Wrap your React app with SessionProvider import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) } 5. Make a component AI-controllable Option A \u2014 hook (no scanner needed): import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' } ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> </ div > ) } Option B \u2014 HOC (annotate + scan): import { reactAI } from '@bnbarak/reactai/react' /** * @reactAi * @key my-card * @description A card component */ interface MyCardProps { /** @reactAi Headline text */ title : string } export const AiMyCard = reactAI ( MyCard , { key : 'my-card' , description : 'A card component' }) 6. Rendering lists of AI-controllable components The two patterns handle multiple instances differently. Hook ( useStateWithAi ) \u2014 singleton per description. All mounts sharing the same description are treated as one logical unit. If you render the same component twice with the same description, the AI sees a single entry and updates both simultaneously. Use this for components that represent a single piece of global or page-level state. HOC ( reactAI() ) \u2014 independent per mount. Each rendered instance gets its own stable ID. Render 10 cards in a list and the AI sees 10 independent entries \u2014 it can update any one specifically. // Each card is independently AI-controllable export const AiProductCard = reactAI ( ProductCard , { key : 'product-card' , description : 'A product card' , }) // In your list \u2014 no extra setup needed export const ProductList = ({ products } : { products : Product [] }) => ( < div > { products . map ( p => ( < AiProductCard key = { p . id } title = { p . title } price = { p . price } /> ))} </ div > ) The AI can now respond to prompts like \"mark the second card as out of stock\" or \"update the price on the laptop card\" \u2014 it resolves which instance to patch from the snapshot context. 7. Tell the agent where it is Use useAiMarker to give the agent ambient context \u2014 what page is active, what mode the app is in, anything that helps it reason about the current state. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } This is how prompts like \"Go to the Kanban tab and move Alice's tasks to Bob\" work \u2014 the agent sees activePage: 'kanban' in its context and knows which components are relevant. 8. Send a prompt From anywhere in your app, post to /api/ai/prompt : await fetch ( '/api/ai/prompt' , { method : 'POST' , headers : { 'Content-Type' : 'application/json' }, body : JSON.stringify ({ sessionId , prompt : 'Change the username to alice' , snapshot }), }) The component re-renders with the AI-applied patch automatically. What's next? Use Cases \u2014 what AI-first component control unlocks Architecture \u2014 full API reference for bridge, server, scanner, and SDK","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Node.js 18+ An existing Express + React app Anthropic API key","title":"Prerequisites"},{"location":"quickstart/#1-install-packages","text":"npm install @bnbarak/reactai That's it \u2014 one package. Use subpath imports to pull in only what you need: Subpath Who uses it @bnbarak/reactai/react Your React app @bnbarak/reactai/server Your Express server @bnbarak/reactai/scanner Build step (CLI)","title":"1. Install packages"},{"location":"quickstart/#2-scan-your-components-build-step","text":"Add the scan script to your package.json : { \"scripts\" : { \"scan\" : \"npx react-ai-scan src/ ./registry.json\" } } Run it once to generate registry.json : npm run scan Tip Add scan as a pre-build step so the registry stays up to date automatically.","title":"2. Scan your components (build step)"},{"location":"quickstart/#3-mount-the-router-on-your-express-server","text":"import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 )","title":"3. Mount the router on your Express server"},{"location":"quickstart/#4-wrap-your-react-app-with-sessionprovider","text":"import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) }","title":"4. Wrap your React app with SessionProvider"},{"location":"quickstart/#5-make-a-component-ai-controllable","text":"Option A \u2014 hook (no scanner needed): import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' } ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> </ div > ) } Option B \u2014 HOC (annotate + scan): import { reactAI } from '@bnbarak/reactai/react' /** * @reactAi * @key my-card * @description A card component */ interface MyCardProps { /** @reactAi Headline text */ title : string } export const AiMyCard = reactAI ( MyCard , { key : 'my-card' , description : 'A card component' })","title":"5. Make a component AI-controllable"},{"location":"quickstart/#6-rendering-lists-of-ai-controllable-components","text":"The two patterns handle multiple instances differently. Hook ( useStateWithAi ) \u2014 singleton per description. All mounts sharing the same description are treated as one logical unit. If you render the same component twice with the same description, the AI sees a single entry and updates both simultaneously. Use this for components that represent a single piece of global or page-level state. HOC ( reactAI() ) \u2014 independent per mount. Each rendered instance gets its own stable ID. Render 10 cards in a list and the AI sees 10 independent entries \u2014 it can update any one specifically. // Each card is independently AI-controllable export const AiProductCard = reactAI ( ProductCard , { key : 'product-card' , description : 'A product card' , }) // In your list \u2014 no extra setup needed export const ProductList = ({ products } : { products : Product [] }) => ( < div > { products . map ( p => ( < AiProductCard key = { p . id } title = { p . title } price = { p . price } /> ))} </ div > ) The AI can now respond to prompts like \"mark the second card as out of stock\" or \"update the price on the laptop card\" \u2014 it resolves which instance to patch from the snapshot context.","title":"6. Rendering lists of AI-controllable components"},{"location":"quickstart/#7-tell-the-agent-where-it-is","text":"Use useAiMarker to give the agent ambient context \u2014 what page is active, what mode the app is in, anything that helps it reason about the current state. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } This is how prompts like \"Go to the Kanban tab and move Alice's tasks to Bob\" work \u2014 the agent sees activePage: 'kanban' in its context and knows which components are relevant.","title":"7. Tell the agent where it is"},{"location":"quickstart/#8-send-a-prompt","text":"From anywhere in your app, post to /api/ai/prompt : await fetch ( '/api/ai/prompt' , { method : 'POST' , headers : { 'Content-Type' : 'application/json' }, body : JSON.stringify ({ sessionId , prompt : 'Change the username to alice' , snapshot }), }) The component re-renders with the AI-applied patch automatically.","title":"8. Send a prompt"},{"location":"quickstart/#whats-next","text":"Use Cases \u2014 what AI-first component control unlocks Architecture \u2014 full API reference for bridge, server, scanner, and SDK","title":"What's next?"},{"location":"scanner/","text":"The scanner is a build-time CLI that reads your TypeScript source, finds annotated component interfaces, and writes a registry.json file. The server loads this file at startup to know which components exist and what the AI is allowed to change. When you need it Only when using the reactAI() HOC pattern. Components that use useStateWithAi() are self-describing at runtime \u2014 they send their own description, writable props, and current state with every prompt. Pattern Scanner needed? useStateWithAi() No \u2014 self-describing at runtime reactAI() HOC Yes \u2014 prop metadata comes from registry.json How it works The scanner uses ts-morph to traverse the TypeScript AST. For every interface it finds, it checks for a @reactAi JSDoc tag. If present, it extracts the key, description, and per-prop annotations to build a ComponentManifest . Source files (. ts , . tsx ) \u2192 AST traversal ( ts - morph ) \u2192 find interfaces with @ reactAi tag \u2192 extract @ key , @ description , @ contextSummary \u2192 per - prop : collect @ reactAi and type info \u2192 derive JSON Schema from TypeScript types \u2192 write registry . json The scanner does not import or execute your code. It reads the AST statically \u2014 no JSX runtime, no React, no bundler needed. Annotating a component Add JSDoc tags to the props interface. The component implementation is untouched. /** * @reactAi * @key product-card * @description A product card showing a title, price, and availability status. * @contextSummary Rendered in the main product grid. Price is in USD. */ interface ProductCardProps { /** @reactAi Headline text for the product */ title : string /** @reactAi Price in USD */ price : number /** @reactAi Availability status */ status : 'in-stock' | 'low-stock' | 'out-of-stock' /** @reactAi Whether to show the sale badge */ onSale? : boolean /** Internal click handler \u2014 never AI-writable */ onAddToCart : () => void } Interface-level tags Tag Required Description @reactAi \u2713 Marks the interface for scanning @key \u2713 Stable identifier used in patches and SSE events. Use kebab-case. @description \u2713 What this component represents. The AI reads this when deciding which component to update. @contextSummary \u2014 Extra context injected into the LLM prompt. Use for placement, constraints, or units. Prop-level tags Tag Description @reactAi <label> Marks the prop as AI-writable. The label is informational. @noAI Explicitly excludes the prop. Optional \u2014 unannotated props are already excluded. Function props are always excluded , even if annotated with @reactAi . The scanner ignores any prop whose type text contains => or Function . Supported TypeScript types The scanner derives a JSON Schema from each prop's TypeScript type. TypeScript JSON Schema string { \"type\": \"string\" } number { \"type\": \"number\" } boolean { \"type\": \"boolean\" } 'a' \\| 'b' \\| 'c' { \"type\": \"string\", \"enum\": [\"a\", \"b\", \"c\"] } string[] { \"type\": \"array\", \"items\": { \"type\": \"string\" } } number[] { \"type\": \"array\", \"items\": { \"type\": \"number\" } } anything else { \"type\": \"string\" } (safe fallback) Required vs optional follows the TypeScript ? token \u2014 optional props are excluded from the required array. CLI npx react-ai-scan <srcDir> <outDir> Argument Description srcDir Directory to scan recursively. Picks up **/*.ts and **/*.tsx . outDir Directory where registry.json is written. Created if it doesn't exist. Add to package.json : { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry\" } } npm run scan # Scanned 4 component(s) \u2192 ./registry/registry.json Run before the server createReactAiRouter({ registryPath }) throws immediately at startup if the file is missing. Add scan as a prerequisite of your server start script: json \"dev:server\": \"npm run scan && tsx server/src/index.ts\" Output: registry.json An array of ComponentManifest objects, one per annotated interface. [ { \"key\" : \"product-card\" , \"description\" : \"A product card showing a title, price, and availability status.\" , \"filePath\" : \"/Users/you/project/src/components/ProductCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"price\" , \"status\" , \"onSale\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"price\" : { \"type\" : \"number\" }, \"status\" : { \"type\" : \"string\" , \"enum\" : [ \"in-stock\" , \"low-stock\" , \"out-of-stock\" ] }, \"onSale\" : { \"type\" : \"boolean\" } }, \"required\" : [ \"title\" , \"price\" , \"status\" ], \"additionalProperties\" : false }, \"contextSummary\" : \"Rendered in the main product grid. Price is in USD.\" } ] Programmatic API The scanner exports three classes from @bnbarak/reactai/scanner for use in build tools, custom scripts, or testing. ComponentScanner import { ComponentScanner } from '@bnbarak/reactai/scanner' const scanner = new ComponentScanner () const manifests = scanner . scan ( './src' ) // \u2192 ComponentManifest[] scan(srcDir: string): ComponentManifest[] Scans all .ts and .tsx files under srcDir recursively. Returns one manifest per annotated interface. Throws if an annotated interface is missing @key or @description . ManifestWriter import { ManifestWriter } from '@bnbarak/reactai/scanner' const writer = new ManifestWriter () writer . write ( manifests , './dist/registry' ) // \u2192 writes ./dist/registry/registry.json write(manifests: ComponentManifest[], outDir: string): void Writes registry.json to outDir . Creates the directory (including nested paths) if it doesn't exist. Overwrites any existing file. SchemaGenerator import { SchemaGenerator } from '@bnbarak/reactai/scanner' const generator = new SchemaGenerator () const schema = generator . generate ( props , aiWritableProps ) // \u2192 JsonSchema generate(props: PropSpec[], aiWritableProps: string[]): JsonSchema Converts an array of PropSpec objects into a JSON Schema. Only props listed in aiWritableProps are included. Useful if you're building a custom scanner or test fixture. interface PropSpec { name : string typeText : string // raw TypeScript type string, e.g. \"'light' | 'dark'\" isOptional : boolean } Error handling The scanner throws on malformed annotations \u2014 it does not silently skip them. Condition Error @reactAi interface missing @key Interface MyProps missing @key tag @reactAi interface missing @description Interface MyProps missing @description tag This ensures bad annotations are caught at build time, not discovered at runtime when the AI can't find a component.","title":"Scanner"},{"location":"scanner/#when-you-need-it","text":"Only when using the reactAI() HOC pattern. Components that use useStateWithAi() are self-describing at runtime \u2014 they send their own description, writable props, and current state with every prompt. Pattern Scanner needed? useStateWithAi() No \u2014 self-describing at runtime reactAI() HOC Yes \u2014 prop metadata comes from registry.json","title":"When you need it"},{"location":"scanner/#how-it-works","text":"The scanner uses ts-morph to traverse the TypeScript AST. For every interface it finds, it checks for a @reactAi JSDoc tag. If present, it extracts the key, description, and per-prop annotations to build a ComponentManifest . Source files (. ts , . tsx ) \u2192 AST traversal ( ts - morph ) \u2192 find interfaces with @ reactAi tag \u2192 extract @ key , @ description , @ contextSummary \u2192 per - prop : collect @ reactAi and type info \u2192 derive JSON Schema from TypeScript types \u2192 write registry . json The scanner does not import or execute your code. It reads the AST statically \u2014 no JSX runtime, no React, no bundler needed.","title":"How it works"},{"location":"scanner/#annotating-a-component","text":"Add JSDoc tags to the props interface. The component implementation is untouched. /** * @reactAi * @key product-card * @description A product card showing a title, price, and availability status. * @contextSummary Rendered in the main product grid. Price is in USD. */ interface ProductCardProps { /** @reactAi Headline text for the product */ title : string /** @reactAi Price in USD */ price : number /** @reactAi Availability status */ status : 'in-stock' | 'low-stock' | 'out-of-stock' /** @reactAi Whether to show the sale badge */ onSale? : boolean /** Internal click handler \u2014 never AI-writable */ onAddToCart : () => void } Interface-level tags Tag Required Description @reactAi \u2713 Marks the interface for scanning @key \u2713 Stable identifier used in patches and SSE events. Use kebab-case. @description \u2713 What this component represents. The AI reads this when deciding which component to update. @contextSummary \u2014 Extra context injected into the LLM prompt. Use for placement, constraints, or units. Prop-level tags Tag Description @reactAi <label> Marks the prop as AI-writable. The label is informational. @noAI Explicitly excludes the prop. Optional \u2014 unannotated props are already excluded. Function props are always excluded , even if annotated with @reactAi . The scanner ignores any prop whose type text contains => or Function .","title":"Annotating a component"},{"location":"scanner/#supported-typescript-types","text":"The scanner derives a JSON Schema from each prop's TypeScript type. TypeScript JSON Schema string { \"type\": \"string\" } number { \"type\": \"number\" } boolean { \"type\": \"boolean\" } 'a' \\| 'b' \\| 'c' { \"type\": \"string\", \"enum\": [\"a\", \"b\", \"c\"] } string[] { \"type\": \"array\", \"items\": { \"type\": \"string\" } } number[] { \"type\": \"array\", \"items\": { \"type\": \"number\" } } anything else { \"type\": \"string\" } (safe fallback) Required vs optional follows the TypeScript ? token \u2014 optional props are excluded from the required array.","title":"Supported TypeScript types"},{"location":"scanner/#cli","text":"npx react-ai-scan <srcDir> <outDir> Argument Description srcDir Directory to scan recursively. Picks up **/*.ts and **/*.tsx . outDir Directory where registry.json is written. Created if it doesn't exist. Add to package.json : { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry\" } } npm run scan # Scanned 4 component(s) \u2192 ./registry/registry.json Run before the server createReactAiRouter({ registryPath }) throws immediately at startup if the file is missing. Add scan as a prerequisite of your server start script: json \"dev:server\": \"npm run scan && tsx server/src/index.ts\"","title":"CLI"},{"location":"scanner/#output-registryjson","text":"An array of ComponentManifest objects, one per annotated interface. [ { \"key\" : \"product-card\" , \"description\" : \"A product card showing a title, price, and availability status.\" , \"filePath\" : \"/Users/you/project/src/components/ProductCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"price\" , \"status\" , \"onSale\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"price\" : { \"type\" : \"number\" }, \"status\" : { \"type\" : \"string\" , \"enum\" : [ \"in-stock\" , \"low-stock\" , \"out-of-stock\" ] }, \"onSale\" : { \"type\" : \"boolean\" } }, \"required\" : [ \"title\" , \"price\" , \"status\" ], \"additionalProperties\" : false }, \"contextSummary\" : \"Rendered in the main product grid. Price is in USD.\" } ]","title":"Output: registry.json"},{"location":"scanner/#programmatic-api","text":"The scanner exports three classes from @bnbarak/reactai/scanner for use in build tools, custom scripts, or testing.","title":"Programmatic API"},{"location":"scanner/#componentscanner","text":"import { ComponentScanner } from '@bnbarak/reactai/scanner' const scanner = new ComponentScanner () const manifests = scanner . scan ( './src' ) // \u2192 ComponentManifest[] scan(srcDir: string): ComponentManifest[] Scans all .ts and .tsx files under srcDir recursively. Returns one manifest per annotated interface. Throws if an annotated interface is missing @key or @description .","title":"ComponentScanner"},{"location":"scanner/#manifestwriter","text":"import { ManifestWriter } from '@bnbarak/reactai/scanner' const writer = new ManifestWriter () writer . write ( manifests , './dist/registry' ) // \u2192 writes ./dist/registry/registry.json write(manifests: ComponentManifest[], outDir: string): void Writes registry.json to outDir . Creates the directory (including nested paths) if it doesn't exist. Overwrites any existing file.","title":"ManifestWriter"},{"location":"scanner/#schemagenerator","text":"import { SchemaGenerator } from '@bnbarak/reactai/scanner' const generator = new SchemaGenerator () const schema = generator . generate ( props , aiWritableProps ) // \u2192 JsonSchema generate(props: PropSpec[], aiWritableProps: string[]): JsonSchema Converts an array of PropSpec objects into a JSON Schema. Only props listed in aiWritableProps are included. Useful if you're building a custom scanner or test fixture. interface PropSpec { name : string typeText : string // raw TypeScript type string, e.g. \"'light' | 'dark'\" isOptional : boolean }","title":"SchemaGenerator"},{"location":"scanner/#error-handling","text":"The scanner throws on malformed annotations \u2014 it does not silently skip them. Condition Error @reactAi interface missing @key Interface MyProps missing @key tag @reactAi interface missing @description Interface MyProps missing @description tag This ensures bad annotations are caught at build time, not discovered at runtime when the AI can't find a component.","title":"Error handling"},{"location":"use-cases/","text":"reactAI is built on a specific premise: an AI that understands your app's data model will always outperform an AI that mimics a user . Most AI agents interact with websites the same way a human would \u2014 they read the screen, find a button, click it, wait for a response, find the next input, type into it. This works. But it's slow, fragile, and fundamentally limited by the fact that the UI was designed for humans, not agents. reactAI takes a different position. The AI operates at the component layer, not the DOM layer. It doesn't simulate a user \u2014 it directly updates state, the same way React itself does. Why browser agents struggle A browser agent sees your app the way a stranger sees a locked room through a keyhole: it can observe, but it can't participate. They work with representations, not data. A browser agent sees \"$142.50\" . reactAI sees { price: 142.5, currency: \"USD\" } . When the agent needs to change the price, it has to locate the right element on the screen, figure out the input field, clear it, type the new value, and submit \u2014 hoping the format is right. reactAI sends { price: 189.0 } . They operate serially. Browser agents act one step at a time: click, wait, type, wait, click. To update five components, they take five separate actions. reactAI sends one patch that touches any number of components simultaneously. They can't distinguish intent from side effects. Clicking \"Save\" on a form might trigger a validation flow, fire an analytics event, navigate to a new page, or trigger a toast. A browser agent has no way to know \u2014 it just clicks and hopes. reactAI only updates the props you declared as AI-writable. Functions, event handlers, and callbacks are never touched. They break when the UI shifts. CSS changes, element repositioning, new overlays, animations mid-flight \u2014 all of these break a browser agent's selectors. reactAI is bound to the component, not the DOM. A layout refactor doesn't affect it at all. They can't reason about state. A browser agent infers state from what it sees. If a button is disabled, the agent has to guess why. reactAI receives the actual current state of every mounted component with every prompt \u2014 { column: \"in-progress\", priority: \"high\", assignee: \"alice\" } \u2014 and can reason directly from it. What reactAI enables Live demos and sales scenarios Demos run on real apps with real data. When a prospect asks \"what does a bad quarter look like?\" you don't want to manually edit 12 fields across 6 components. \"Show the portfolio dashboard after a rough week \u2014 AAPL down 12%, everything in the red\" reactAI patches every stock card simultaneously. The dashboard updates in one round-trip. The demo keeps moving. A browser agent would have to navigate to each card's edit view, find the price field, clear it, type a new value, and save \u2014 then repeat for every card. That's not a demo, that's data entry. AI copilots in complex dashboards The value of an AI copilot comes from understanding what's on the screen and acting on it \u2014 not just answering questions about it. \"Move all of Alice's overdue tasks to Bob and mark them urgent\" reactAI reads the current snapshot: all Kanban cards, their assignees, their due dates, their priorities. It produces a single patch that updates the relevant cards. No navigation, no clicking through card menus, no drag-and-drop simulation. This is what \"operating the app\" looks like from the inside. The AI doesn't pretend to be a user \u2014 it acts as a peer system with direct access to the data model. What-if simulations Financial dashboards, operations tools, and analytics platforms all have the same need: show me a different state without changing real data. \"Simulate Q4 if we hit our stretch targets \u2014 spike the weekly activity chart, update the revenue metric , and show the 'on track' badge on the OKR panel \" A browser agent has to find each component, find its edit controls, make changes one at a time. reactAI sends one patch. All components update atomically. When the demo is over, there's no cleanup \u2014 nothing was persisted. Rapid QA and scenario setup Getting an application into a specific state for testing is expensive. Clicking through five screens to reproduce an edge case takes time and breaks as the UI changes. \"Set up the checkout with three items in the cart, one out of stock, and a 10 % coupon applied \u2014 show the error state for the out - of - stock item \" reactAI sets this up in one call. QA engineers describe the scenario in plain language. The AI maps it to the component tree and patches accordingly. No click scripts, no fixture files, no Playwright chains. Personalization and UI adaptation \"Switch to the high-contrast theme, increase all text to large, and collapse the sidebar\" When UI preferences span multiple components \u2014 theme provider, font settings, layout state \u2014 coordinating them through DOM interaction is tedious. reactAI patches them together. The user says what they want; the AI applies it everywhere at once. Presentation and content staging Marketing teams, designers, and product managers frequently need to show the UI in a specific state \u2014 for a screenshot, a review, a stakeholder presentation. \"Update the store banner to announce the summer sale, feature the headphones at $69, and mark the running shoes as sold out\" Instead of a series of CMS edits across three different panels, this is a single prompt. Every component that needs to change, changes \u2014 simultaneously, correctly. The underlying difference Browser agents are pilots who fly by looking out the window. reactAI gives the AI the instrument panel. The instrument panel knows airspeed as a number, not as a needle position on a gauge. It accepts inputs directly \u2014 set altitude to 35,000, set heading to 270 \u2014 without simulating the physical act of turning a knob. It can update multiple instruments simultaneously without a sequence of manual adjustments. That's what it means to make AI a first-class citizen for component state. Not a smarter way to click buttons \u2014 a fundamentally different level of access.","title":"Use Cases"},{"location":"use-cases/#why-browser-agents-struggle","text":"A browser agent sees your app the way a stranger sees a locked room through a keyhole: it can observe, but it can't participate. They work with representations, not data. A browser agent sees \"$142.50\" . reactAI sees { price: 142.5, currency: \"USD\" } . When the agent needs to change the price, it has to locate the right element on the screen, figure out the input field, clear it, type the new value, and submit \u2014 hoping the format is right. reactAI sends { price: 189.0 } . They operate serially. Browser agents act one step at a time: click, wait, type, wait, click. To update five components, they take five separate actions. reactAI sends one patch that touches any number of components simultaneously. They can't distinguish intent from side effects. Clicking \"Save\" on a form might trigger a validation flow, fire an analytics event, navigate to a new page, or trigger a toast. A browser agent has no way to know \u2014 it just clicks and hopes. reactAI only updates the props you declared as AI-writable. Functions, event handlers, and callbacks are never touched. They break when the UI shifts. CSS changes, element repositioning, new overlays, animations mid-flight \u2014 all of these break a browser agent's selectors. reactAI is bound to the component, not the DOM. A layout refactor doesn't affect it at all. They can't reason about state. A browser agent infers state from what it sees. If a button is disabled, the agent has to guess why. reactAI receives the actual current state of every mounted component with every prompt \u2014 { column: \"in-progress\", priority: \"high\", assignee: \"alice\" } \u2014 and can reason directly from it.","title":"Why browser agents struggle"},{"location":"use-cases/#what-reactai-enables","text":"","title":"What reactAI enables"},{"location":"use-cases/#live-demos-and-sales-scenarios","text":"Demos run on real apps with real data. When a prospect asks \"what does a bad quarter look like?\" you don't want to manually edit 12 fields across 6 components. \"Show the portfolio dashboard after a rough week \u2014 AAPL down 12%, everything in the red\" reactAI patches every stock card simultaneously. The dashboard updates in one round-trip. The demo keeps moving. A browser agent would have to navigate to each card's edit view, find the price field, clear it, type a new value, and save \u2014 then repeat for every card. That's not a demo, that's data entry.","title":"Live demos and sales scenarios"},{"location":"use-cases/#ai-copilots-in-complex-dashboards","text":"The value of an AI copilot comes from understanding what's on the screen and acting on it \u2014 not just answering questions about it. \"Move all of Alice's overdue tasks to Bob and mark them urgent\" reactAI reads the current snapshot: all Kanban cards, their assignees, their due dates, their priorities. It produces a single patch that updates the relevant cards. No navigation, no clicking through card menus, no drag-and-drop simulation. This is what \"operating the app\" looks like from the inside. The AI doesn't pretend to be a user \u2014 it acts as a peer system with direct access to the data model.","title":"AI copilots in complex dashboards"},{"location":"use-cases/#what-if-simulations","text":"Financial dashboards, operations tools, and analytics platforms all have the same need: show me a different state without changing real data. \"Simulate Q4 if we hit our stretch targets \u2014 spike the weekly activity chart, update the revenue metric , and show the 'on track' badge on the OKR panel \" A browser agent has to find each component, find its edit controls, make changes one at a time. reactAI sends one patch. All components update atomically. When the demo is over, there's no cleanup \u2014 nothing was persisted.","title":"What-if simulations"},{"location":"use-cases/#rapid-qa-and-scenario-setup","text":"Getting an application into a specific state for testing is expensive. Clicking through five screens to reproduce an edge case takes time and breaks as the UI changes. \"Set up the checkout with three items in the cart, one out of stock, and a 10 % coupon applied \u2014 show the error state for the out - of - stock item \" reactAI sets this up in one call. QA engineers describe the scenario in plain language. The AI maps it to the component tree and patches accordingly. No click scripts, no fixture files, no Playwright chains.","title":"Rapid QA and scenario setup"},{"location":"use-cases/#personalization-and-ui-adaptation","text":"\"Switch to the high-contrast theme, increase all text to large, and collapse the sidebar\" When UI preferences span multiple components \u2014 theme provider, font settings, layout state \u2014 coordinating them through DOM interaction is tedious. reactAI patches them together. The user says what they want; the AI applies it everywhere at once.","title":"Personalization and UI adaptation"},{"location":"use-cases/#presentation-and-content-staging","text":"Marketing teams, designers, and product managers frequently need to show the UI in a specific state \u2014 for a screenshot, a review, a stakeholder presentation. \"Update the store banner to announce the summer sale, feature the headphones at $69, and mark the running shoes as sold out\" Instead of a series of CMS edits across three different panels, this is a single prompt. Every component that needs to change, changes \u2014 simultaneously, correctly.","title":"Presentation and content staging"},{"location":"use-cases/#the-underlying-difference","text":"Browser agents are pilots who fly by looking out the window. reactAI gives the AI the instrument panel. The instrument panel knows airspeed as a number, not as a needle position on a gauge. It accepts inputs directly \u2014 set altitude to 35,000, set heading to 270 \u2014 without simulating the physical act of turning a knob. It can update multiple instruments simultaneously without a sequence of manual adjustments. That's what it means to make AI a first-class citizen for component state. Not a smarter way to click buttons \u2014 a fundamentally different level of access.","title":"The underlying difference"},{"location":"guides/architecture/","text":"reactAI is a closed-loop system: React state \u2192 prompt \u2192 LLM \u2192 patch \u2192 React state. How it works A user types a prompt. The bridge collects a snapshot of all currently mounted AI-controllable components and posts it to the server. The server makes a single LLM call that selects the target component and produces the patch. The patch is broadcast via SSE. The matching component merges it into React state and re-renders. Mount : Components register their current state in a client - side SnapshotRegistry Prompt : Your app posts { prompt , snapshot } to the server Server merges the live snapshot with the static registry One LLM call returns { key , instanceId , patch } Server broadcasts the patch via SSE Apply : Bridge receives the SSE event The matching component merges the patch into React state Component re - renders Design principles All state lives on the client. The server never stores component state between requests. Every prompt submission sends a full snapshot of all currently mounted AI-controllable components. This keeps the server stateless and horizontally scalable \u2014 no sticky sessions, no shared memory. One LLM call per turn. A single Anthropic API call selects the target component and generates the patch in one shot. No two-step \"select then generate\" flow. This halves latency and keeps the context small. Components describe themselves. With useStateWithAi , the component description, current state, and writable props all travel with every prompt. The AI always sees fresh context \u2014 no stale cache, no separate sync step. Fail fast. The server throws on startup if registryPath is given but the file doesn't exist. Patches that reference non-AI-writable props are rejected with 422. There is no silent fallback. Packages Package What it does Who uses it server Express router \u2014 sessions, SSE, patch validation, AI prompt Your backend bridge React hooks + HOC + SSE client Your React app scanner Build-time CLI \u2014 AST scan \u2192 registry.json Your CI / build step sdk LLM orchestration (Anthropic) Passed into server core Shared TypeScript types All packages demo/server and demo/webapp are not published \u2014 they're the development sandbox. Two component patterns Pattern When to use Scanner needed? useStateWithAi() State owned by the component (form fields, toggles, display values) No reactAI() HOC Prop-based components from a design system or library Yes Prefer useStateWithAi for new components. Use the HOC when you can't modify the component's internals. Bridge (React) The bridge is how your React components become AI-controllable. It handles session management, state registration, and applying AI patches \u2014 so your components just render normally. SessionProvider Wrap your app once at the root. It creates a server session on mount and makes sessionId and serverUrl available throughout the tree. import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) } Prop Type Description serverUrl string Full URL including the mount path. Defaults to http://localhost:3001/api . children ReactNode Your app. Same-origin deployment When your React app and server are on the same domain, use a relative URL: tsx <SessionProvider serverUrl=\"/api\"> useStateWithAi Drop-in replacement for useState . Give your state a description \u2014 the AI uses it to understand what this state represents. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, // context: enum options ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> < select value = { state . language } onChange = { e => setState ({ ... state , language : e.target.value })} > {[ 'English' , 'Hebrew' , 'Spanish' ]. map ( l => < option key = { l }>{ l }</ option >)} </ select > </ div > ) } Key derivation: The description is slugified to become the component key. \"User profile settings\" \u2192 \"user-profile-settings\" aiRef : Attach to your root DOM element. The bridge uses it to set data-ai-id for the accessibility tree snapshot. context : Optional third argument. Pass arrays of valid options for enum-like props. The AI receives these as allowed values. Singleton behaviour: Two components with the same description share the same AI key. This is intentional \u2014 if you have a username field in a header and a settings form, describing both as 'User profile settings' means the AI treats them as the same logical unit. reactAI() HOC Wraps a prop-based component. The HOC applies AI patches on top of whatever props you pass in. import { reactAI } from '@bnbarak/reactai/react' // Wrap once, use everywhere export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and call-to-action' , }) // Use like the original component < AiCard title = \"Hello\" body = \"World\" onButtonClick = { handleClick } /> The base props are always passed through. The AI can only override props listed in aiWritableProps (set by the scanner annotation). Non-AI-writable props like onButtonClick are never touched. Each <AiCard /> mount gets a random stable instanceId , so multiple cards on screen are independently controllable. Requires scanner The HOC pattern requires the component's props interface to be annotated with @reactAi and scanned into registry.json . See the Scanner section below. useAiMarker Register a named value the AI can see in its context snapshot. Use it to tell the AI what page or region is currently active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } The marker is registered on mount and removed on unmount. Pass any serialisable value \u2014 strings, numbers, or objects. Server The server package is a single Express router. Mount it anywhere in your existing Express app \u2014 it doesn't dictate your app structure. import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 ) Mount at whatever path you like. The bridge's SessionProvider takes the matching serverUrl . Options Option Type Description registryPath string Path to registry.json . Loaded synchronously at startup \u2014 throws if file is missing. manifests ComponentManifest[] Pass pre-loaded manifests directly instead of a file path. sdk AiSdkLike The LLM SDK instance. Required for /ai/prompt . Omit to disable that route. No SDK, no AI route You can run the server without an SDK \u2014 sessions, SSE, and direct patch routes still work. Useful for testing the bridge in isolation. Routes POST / sessions \u2192 { sessionId } GET / registry \u2192 ComponentManifest [] GET / registry /: key \u2192 ComponentManifest POST / patches \u2192 validate + SSE broadcast GET / sse /: sessionId \u2192 SSE stream POST / ai / prompt \u2192 LLM call + SSE broadcast ( requires sdk ) POST /patches \u2014 Apply a patch directly without the LLM. Useful for testing or deterministic updates from your own code. // Request { \"sessionId\" : \"...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"inst-1\" , \"patch\" : { \"title\" : \"New Title\" } } // Response { \"applied\" : true } Returns 422 if any key in patch is not listed in the component's aiWritableProps . POST /ai/prompt \u2014 Main AI entry point. Accepts a prompt and a full component snapshot. { \"sessionId\" : \"...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ] } The server merges snapshot with registry.json (snapshot entries take priority), calls the SDK, then broadcasts the patch via SSE. AiSdkLike interface The server depends on a single interface \u2014 not on the Anthropic SDK directly. You can pass any object that satisfies it: interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean } > } This makes the server testable with mock SDKs and lets you swap LLM providers without touching the server. Scanner The scanner reads your TypeScript source at build time and extracts component metadata into registry.json . The server and SDK use this file to understand what components exist and what the AI is allowed to change. You only need the scanner if you're using the reactAI() HOC pattern. Components using useStateWithAi() describe themselves at runtime. Annotating a component Add a @reactAi JSDoc tag to the props interface: /** * @reactAi * @key demo-card * @description A product card showing a title and CTA button. */ interface DemoCardProps { /** @reactAi Headline text */ title : string /** @reactAi Supporting body copy */ body? : string /** @noAI Internal click handler */ onButtonClick : () => void } Tag Where Meaning @reactAi Interface Marks it for scanning @key Interface Stable identifier used in patches and SSE events @description Interface What the AI sees when deciding which component to update @reactAi Prop Marks it as AI-writable @noAI Prop Explicitly excludes it (optional, self-documenting) Function props ( () => void ) are never AI-writable, even if annotated. Running the scanner npx react-ai-scan <srcDir> <outDir> { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry.json\" } } Run before the server The server throws if registryPath points to a missing file. Make scan a prerequisite of your server start script. Output: registry.json [ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA button.\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ] The JSON Schema is derived from your TypeScript types. string , number , boolean , and union string literals are all supported. SDK The SDK is the LLM layer. It takes a prompt and a component snapshot, and returns a validated patch for the most relevant component. A single Anthropic API call does everything: selects the target component and generates the patch. A two-step \"select then generate\" flow would double the latency and split the context, making it harder for the model to reason about prop values while selecting. The model used is claude-haiku-4-5-20251001 \u2014 optimised for fast, structured output tasks. import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk })) What happens inside updateFromPrompt ( prompt , manifests , mountedSnapshot ) \u2192 CombinedSelector . select ( prompt , manifests , snapshot ) \u2192 one LLM call with tool_use \u2192 returns { key , instanceId , patch } \u2192 RetryValidator . validateWithRetry ( key , patch , manifest ) \u2192 validates patch keys against aiWritableProps \u2192 if invalid : retry with error feedback ( max 2 retries ) \u2192 returns { target , patch , applied , isDone } isDone : The SDK returns isDone: true when the task is complete after the current turn, false when it wants the client to send another turn (multi-step navigation). The bridge loops until isDone is true or max turns is reached. Bring your own model The server depends on AiSdkLike \u2014 not the Anthropic SDK directly. Implement your own to swap providers: import type { AiSdkLike } from '@bnbarak/reactai/server' class MyCustomSdk implements AiSdkLike { async updateFromPrompt ( prompt , manifests , mountedSnapshot ) { // your LLM call here return { target : { key : '...' , instanceId : '...' }, patch : { ... }, applied : true } } } Debugging prompts Set DEBUG=true in your .env to log all LLM prompts to prompts.txt . DEBUG = true npm run demo:server Data shapes Snapshot (sent with every prompt): MountedInstance { key : string // derived from description or HOC config instanceId : string // stable per mount description : string aiWritableProps : string [] currentProps : Record < string , unknown > context? : Record < string , unknown > // enum options for selects, etc. } Patch event (broadcast via SSE): SseEvent { type : 'patch' key : string instanceId : string patch : Record < string , unknown > }","title":"Architecture"},{"location":"guides/architecture/#how-it-works","text":"A user types a prompt. The bridge collects a snapshot of all currently mounted AI-controllable components and posts it to the server. The server makes a single LLM call that selects the target component and produces the patch. The patch is broadcast via SSE. The matching component merges it into React state and re-renders. Mount : Components register their current state in a client - side SnapshotRegistry Prompt : Your app posts { prompt , snapshot } to the server Server merges the live snapshot with the static registry One LLM call returns { key , instanceId , patch } Server broadcasts the patch via SSE Apply : Bridge receives the SSE event The matching component merges the patch into React state Component re - renders","title":"How it works"},{"location":"guides/architecture/#design-principles","text":"All state lives on the client. The server never stores component state between requests. Every prompt submission sends a full snapshot of all currently mounted AI-controllable components. This keeps the server stateless and horizontally scalable \u2014 no sticky sessions, no shared memory. One LLM call per turn. A single Anthropic API call selects the target component and generates the patch in one shot. No two-step \"select then generate\" flow. This halves latency and keeps the context small. Components describe themselves. With useStateWithAi , the component description, current state, and writable props all travel with every prompt. The AI always sees fresh context \u2014 no stale cache, no separate sync step. Fail fast. The server throws on startup if registryPath is given but the file doesn't exist. Patches that reference non-AI-writable props are rejected with 422. There is no silent fallback.","title":"Design principles"},{"location":"guides/architecture/#packages","text":"Package What it does Who uses it server Express router \u2014 sessions, SSE, patch validation, AI prompt Your backend bridge React hooks + HOC + SSE client Your React app scanner Build-time CLI \u2014 AST scan \u2192 registry.json Your CI / build step sdk LLM orchestration (Anthropic) Passed into server core Shared TypeScript types All packages demo/server and demo/webapp are not published \u2014 they're the development sandbox.","title":"Packages"},{"location":"guides/architecture/#two-component-patterns","text":"Pattern When to use Scanner needed? useStateWithAi() State owned by the component (form fields, toggles, display values) No reactAI() HOC Prop-based components from a design system or library Yes Prefer useStateWithAi for new components. Use the HOC when you can't modify the component's internals.","title":"Two component patterns"},{"location":"guides/architecture/#bridge-react","text":"The bridge is how your React components become AI-controllable. It handles session management, state registration, and applying AI patches \u2014 so your components just render normally.","title":"Bridge (React)"},{"location":"guides/architecture/#sessionprovider","text":"Wrap your app once at the root. It creates a server session on mount and makes sessionId and serverUrl available throughout the tree. import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) } Prop Type Description serverUrl string Full URL including the mount path. Defaults to http://localhost:3001/api . children ReactNode Your app. Same-origin deployment When your React app and server are on the same domain, use a relative URL: tsx <SessionProvider serverUrl=\"/api\">","title":"SessionProvider"},{"location":"guides/architecture/#usestatewithai","text":"Drop-in replacement for useState . Give your state a description \u2014 the AI uses it to understand what this state represents. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, // context: enum options ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> < select value = { state . language } onChange = { e => setState ({ ... state , language : e.target.value })} > {[ 'English' , 'Hebrew' , 'Spanish' ]. map ( l => < option key = { l }>{ l }</ option >)} </ select > </ div > ) } Key derivation: The description is slugified to become the component key. \"User profile settings\" \u2192 \"user-profile-settings\" aiRef : Attach to your root DOM element. The bridge uses it to set data-ai-id for the accessibility tree snapshot. context : Optional third argument. Pass arrays of valid options for enum-like props. The AI receives these as allowed values. Singleton behaviour: Two components with the same description share the same AI key. This is intentional \u2014 if you have a username field in a header and a settings form, describing both as 'User profile settings' means the AI treats them as the same logical unit.","title":"useStateWithAi"},{"location":"guides/architecture/#reactai-hoc","text":"Wraps a prop-based component. The HOC applies AI patches on top of whatever props you pass in. import { reactAI } from '@bnbarak/reactai/react' // Wrap once, use everywhere export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and call-to-action' , }) // Use like the original component < AiCard title = \"Hello\" body = \"World\" onButtonClick = { handleClick } /> The base props are always passed through. The AI can only override props listed in aiWritableProps (set by the scanner annotation). Non-AI-writable props like onButtonClick are never touched. Each <AiCard /> mount gets a random stable instanceId , so multiple cards on screen are independently controllable. Requires scanner The HOC pattern requires the component's props interface to be annotated with @reactAi and scanned into registry.json . See the Scanner section below.","title":"reactAI() HOC"},{"location":"guides/architecture/#useaimarker","text":"Register a named value the AI can see in its context snapshot. Use it to tell the AI what page or region is currently active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } The marker is registered on mount and removed on unmount. Pass any serialisable value \u2014 strings, numbers, or objects.","title":"useAiMarker"},{"location":"guides/architecture/#server","text":"The server package is a single Express router. Mount it anywhere in your existing Express app \u2014 it doesn't dictate your app structure. import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 ) Mount at whatever path you like. The bridge's SessionProvider takes the matching serverUrl .","title":"Server"},{"location":"guides/architecture/#options","text":"Option Type Description registryPath string Path to registry.json . Loaded synchronously at startup \u2014 throws if file is missing. manifests ComponentManifest[] Pass pre-loaded manifests directly instead of a file path. sdk AiSdkLike The LLM SDK instance. Required for /ai/prompt . Omit to disable that route. No SDK, no AI route You can run the server without an SDK \u2014 sessions, SSE, and direct patch routes still work. Useful for testing the bridge in isolation.","title":"Options"},{"location":"guides/architecture/#routes","text":"POST / sessions \u2192 { sessionId } GET / registry \u2192 ComponentManifest [] GET / registry /: key \u2192 ComponentManifest POST / patches \u2192 validate + SSE broadcast GET / sse /: sessionId \u2192 SSE stream POST / ai / prompt \u2192 LLM call + SSE broadcast ( requires sdk ) POST /patches \u2014 Apply a patch directly without the LLM. Useful for testing or deterministic updates from your own code. // Request { \"sessionId\" : \"...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"inst-1\" , \"patch\" : { \"title\" : \"New Title\" } } // Response { \"applied\" : true } Returns 422 if any key in patch is not listed in the component's aiWritableProps . POST /ai/prompt \u2014 Main AI entry point. Accepts a prompt and a full component snapshot. { \"sessionId\" : \"...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ] } The server merges snapshot with registry.json (snapshot entries take priority), calls the SDK, then broadcasts the patch via SSE.","title":"Routes"},{"location":"guides/architecture/#aisdklike-interface","text":"The server depends on a single interface \u2014 not on the Anthropic SDK directly. You can pass any object that satisfies it: interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean } > } This makes the server testable with mock SDKs and lets you swap LLM providers without touching the server.","title":"AiSdkLike interface"},{"location":"guides/architecture/#scanner","text":"The scanner reads your TypeScript source at build time and extracts component metadata into registry.json . The server and SDK use this file to understand what components exist and what the AI is allowed to change. You only need the scanner if you're using the reactAI() HOC pattern. Components using useStateWithAi() describe themselves at runtime.","title":"Scanner"},{"location":"guides/architecture/#annotating-a-component","text":"Add a @reactAi JSDoc tag to the props interface: /** * @reactAi * @key demo-card * @description A product card showing a title and CTA button. */ interface DemoCardProps { /** @reactAi Headline text */ title : string /** @reactAi Supporting body copy */ body? : string /** @noAI Internal click handler */ onButtonClick : () => void } Tag Where Meaning @reactAi Interface Marks it for scanning @key Interface Stable identifier used in patches and SSE events @description Interface What the AI sees when deciding which component to update @reactAi Prop Marks it as AI-writable @noAI Prop Explicitly excludes it (optional, self-documenting) Function props ( () => void ) are never AI-writable, even if annotated.","title":"Annotating a component"},{"location":"guides/architecture/#running-the-scanner","text":"npx react-ai-scan <srcDir> <outDir> { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry.json\" } } Run before the server The server throws if registryPath points to a missing file. Make scan a prerequisite of your server start script.","title":"Running the scanner"},{"location":"guides/architecture/#output-registryjson","text":"[ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA button.\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ] The JSON Schema is derived from your TypeScript types. string , number , boolean , and union string literals are all supported.","title":"Output: registry.json"},{"location":"guides/architecture/#sdk","text":"The SDK is the LLM layer. It takes a prompt and a component snapshot, and returns a validated patch for the most relevant component. A single Anthropic API call does everything: selects the target component and generates the patch. A two-step \"select then generate\" flow would double the latency and split the context, making it harder for the model to reason about prop values while selecting. The model used is claude-haiku-4-5-20251001 \u2014 optimised for fast, structured output tasks. import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk }))","title":"SDK"},{"location":"guides/architecture/#what-happens-inside","text":"updateFromPrompt ( prompt , manifests , mountedSnapshot ) \u2192 CombinedSelector . select ( prompt , manifests , snapshot ) \u2192 one LLM call with tool_use \u2192 returns { key , instanceId , patch } \u2192 RetryValidator . validateWithRetry ( key , patch , manifest ) \u2192 validates patch keys against aiWritableProps \u2192 if invalid : retry with error feedback ( max 2 retries ) \u2192 returns { target , patch , applied , isDone } isDone : The SDK returns isDone: true when the task is complete after the current turn, false when it wants the client to send another turn (multi-step navigation). The bridge loops until isDone is true or max turns is reached.","title":"What happens inside"},{"location":"guides/architecture/#bring-your-own-model","text":"The server depends on AiSdkLike \u2014 not the Anthropic SDK directly. Implement your own to swap providers: import type { AiSdkLike } from '@bnbarak/reactai/server' class MyCustomSdk implements AiSdkLike { async updateFromPrompt ( prompt , manifests , mountedSnapshot ) { // your LLM call here return { target : { key : '...' , instanceId : '...' }, patch : { ... }, applied : true } } }","title":"Bring your own model"},{"location":"guides/architecture/#debugging-prompts","text":"Set DEBUG=true in your .env to log all LLM prompts to prompts.txt . DEBUG = true npm run demo:server","title":"Debugging prompts"},{"location":"guides/architecture/#data-shapes","text":"Snapshot (sent with every prompt): MountedInstance { key : string // derived from description or HOC config instanceId : string // stable per mount description : string aiWritableProps : string [] currentProps : Record < string , unknown > context? : Record < string , unknown > // enum options for selects, etc. } Patch event (broadcast via SSE): SseEvent { type : 'patch' key : string instanceId : string patch : Record < string , unknown > }","title":"Data shapes"},{"location":"guides/bridge/","text":"The bridge is how your React components become AI-controllable. It handles session management, state registration, and applying AI patches \u2014 so your components just render normally. When to use each API Use useStateWithAi when the component owns its own state \u2014 form fields, display toggles, text labels, selected values. This is the most common pattern. Use reactAI() HOC when you have a prop-based component (from a design system, a library, or a legacy codebase) that you can't or don't want to modify internally. SessionProvider Wrap your app once at the root. It creates a server session on mount and makes sessionId and serverUrl available throughout the tree. import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) } Prop Type Default Description serverUrl string http://localhost:3001/api Full URL including the mount path children ReactNode \u2014 Your app Same-origin deployment When your React app and server are on the same domain, use a relative URL: tsx <SessionProvider serverUrl=\"/api\"> useStateWithAi Drop-in replacement for useState . Give your state a description \u2014 the AI uses it to understand what this state represents. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, // context: enum options ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> < select value = { state . language } onChange = { e => setState ({ ... state , language : e.target.value })} > {[ 'English' , 'Hebrew' , 'Spanish' ]. map ( l => < option key = { l }>{ l }</ option >)} </ select > </ div > ) } Key derivation: The description is slugified to become the component key. \"User profile settings\" \u2192 \"user-profile-settings\" aiRef : Attach to your root DOM element. The bridge uses it to set data-ai-id for the accessibility tree snapshot. context : Optional third argument. Pass arrays of valid options for enum-like props. The AI receives these as allowed values. Singleton behaviour Two components with the same description share the same AI key. This is intentional \u2014 if you have a username field in a header and a settings form, describing both as 'User profile settings' means the AI treats them as the same logical unit. reactAI() HOC Wraps a prop-based component. The HOC applies AI patches on top of whatever props you pass in. import { reactAI } from '@bnbarak/reactai/react' // Wrap once, use everywhere export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and call-to-action' , }) // Use like the original component < AiCard title = \"Hello\" body = \"World\" onButtonClick = { handleClick } /> The base props ( title , body , onButtonClick ) are always passed through. The AI can only override props listed in aiWritableProps (set by the scanner annotation). Non-AI-writable props like onButtonClick are never touched. Each <AiCard /> mount gets a random stable instanceId , so multiple cards on screen are independently controllable. Requires scanner The HOC pattern requires the component's props interface to be annotated with @reactAi and scanned into registry.json . See the Scanner guide . useAiMarker Register a named value the AI can see in its context snapshot. Use it to tell the AI what page or region is currently active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } The marker is registered on mount and removed on unmount. Pass any serialisable value \u2014 strings, numbers, or objects. Key files File Role src/SessionContext.tsx SessionProvider + useSession \u2014 session creation and context src/useStateWithAi.ts Hook: description \u2192 key, SnapshotRegistry + SSE subscription src/reactAI.tsx HOC: wraps component, random instanceId, SnapshotRegistry + useAiState src/useAiState.ts SSE subscription filtered by (key, instanceId) src/SnapshotRegistry.ts Module singleton \u2014 all current AI-controllable state src/SseClient.ts EventSource wrapper with automatic reconnect","title":"Bridge"},{"location":"guides/bridge/#when-to-use-each-api","text":"Use useStateWithAi when the component owns its own state \u2014 form fields, display toggles, text labels, selected values. This is the most common pattern. Use reactAI() HOC when you have a prop-based component (from a design system, a library, or a legacy codebase) that you can't or don't want to modify internally.","title":"When to use each API"},{"location":"guides/bridge/#sessionprovider","text":"Wrap your app once at the root. It creates a server session on mount and makes sessionId and serverUrl available throughout the tree. import { SessionProvider } from '@bnbarak/reactai/react' export default function App () { return ( < SessionProvider serverUrl = \"http://localhost:3001/api\" > < YourApp /> </ SessionProvider > ) } Prop Type Default Description serverUrl string http://localhost:3001/api Full URL including the mount path children ReactNode \u2014 Your app Same-origin deployment When your React app and server are on the same domain, use a relative URL: tsx <SessionProvider serverUrl=\"/api\">","title":"SessionProvider"},{"location":"guides/bridge/#usestatewithai","text":"Drop-in replacement for useState . Give your state a description \u2014 the AI uses it to understand what this state represents. import { useStateWithAi } from '@bnbarak/reactai/react' export const ProfileForm = () => { const [ state , setState , aiRef ] = useStateWithAi ( 'User profile settings' , { username : 'barak' , language : 'English' }, { language : [ 'English' , 'Hebrew' , 'Spanish' ] }, // context: enum options ) return ( < div ref = { aiRef }> < input value = { state . username } onChange = { e => setState ({ ... state , username : e.target.value })} /> < select value = { state . language } onChange = { e => setState ({ ... state , language : e.target.value })} > {[ 'English' , 'Hebrew' , 'Spanish' ]. map ( l => < option key = { l }>{ l }</ option >)} </ select > </ div > ) } Key derivation: The description is slugified to become the component key. \"User profile settings\" \u2192 \"user-profile-settings\" aiRef : Attach to your root DOM element. The bridge uses it to set data-ai-id for the accessibility tree snapshot. context : Optional third argument. Pass arrays of valid options for enum-like props. The AI receives these as allowed values.","title":"useStateWithAi"},{"location":"guides/bridge/#singleton-behaviour","text":"Two components with the same description share the same AI key. This is intentional \u2014 if you have a username field in a header and a settings form, describing both as 'User profile settings' means the AI treats them as the same logical unit.","title":"Singleton behaviour"},{"location":"guides/bridge/#reactai-hoc","text":"Wraps a prop-based component. The HOC applies AI patches on top of whatever props you pass in. import { reactAI } from '@bnbarak/reactai/react' // Wrap once, use everywhere export const AiCard = reactAI ( DemoCard , { key : 'demo-card' , description : 'A product card showing a title and call-to-action' , }) // Use like the original component < AiCard title = \"Hello\" body = \"World\" onButtonClick = { handleClick } /> The base props ( title , body , onButtonClick ) are always passed through. The AI can only override props listed in aiWritableProps (set by the scanner annotation). Non-AI-writable props like onButtonClick are never touched. Each <AiCard /> mount gets a random stable instanceId , so multiple cards on screen are independently controllable. Requires scanner The HOC pattern requires the component's props interface to be annotated with @reactAi and scanned into registry.json . See the Scanner guide .","title":"reactAI() HOC"},{"location":"guides/bridge/#useaimarker","text":"Register a named value the AI can see in its context snapshot. Use it to tell the AI what page or region is currently active. import { useAiMarker } from '@bnbarak/reactai/react' export const AppLayout = ({ page } : { page : string }) => { useAiMarker ( 'activePage' , page ) return < div >...</ div > } The marker is registered on mount and removed on unmount. Pass any serialisable value \u2014 strings, numbers, or objects.","title":"useAiMarker"},{"location":"guides/bridge/#key-files","text":"File Role src/SessionContext.tsx SessionProvider + useSession \u2014 session creation and context src/useStateWithAi.ts Hook: description \u2192 key, SnapshotRegistry + SSE subscription src/reactAI.tsx HOC: wraps component, random instanceId, SnapshotRegistry + useAiState src/useAiState.ts SSE subscription filtered by (key, instanceId) src/SnapshotRegistry.ts Module singleton \u2014 all current AI-controllable state src/SseClient.ts EventSource wrapper with automatic reconnect","title":"Key files"},{"location":"guides/scanner/","text":"The scanner reads your TypeScript source at build time and extracts component metadata into registry.json . The server and SDK use this file to understand what components exist and what the AI is allowed to change. When you need it You only need the scanner if you're using the reactAI() HOC pattern. Components using useStateWithAi() describe themselves at runtime \u2014 they don't need the scanner. Pattern Scanner needed? useStateWithAi() No \u2014 self-describing at runtime reactAI() HOC Yes \u2014 props come from the scanner Annotating a component Add a @reactAi JSDoc tag to the props interface. The scanner will extract it. /** * @reactAi * @key demo-card * @description A product card showing a title and CTA button. */ interface DemoCardProps { /** @reactAi Headline text */ title : string /** @reactAi Supporting body copy */ body? : string /** @noAI Internal click handler */ onButtonClick : () => void } Rules: - @reactAi on the interface \u2014 marks it for scanning - @key \u2014 the stable identifier used in patches and SSE events - @description \u2014 what the AI sees when deciding which component to update - @reactAi on a prop \u2014 marks it as AI-writable - @noAI on a prop \u2014 explicitly excludes it (optional, self-documenting) - Function props ( () => void ) are never AI-writable, even if annotated Running the scanner npx react-ai-scan <srcDir> <outDir> Add it to your package.json scripts: { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry.json\" } } Run before the server The server throws if registryPath points to a missing file. Make scan a prerequisite of your server start script. Output: registry.json [ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA button.\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ] The JSON Schema is derived from your TypeScript types. string , number , boolean , and union string literals are supported. Programmatic API The scanner also exports a programmatic API for build tool integration: import { ComponentScanner , ManifestWriter } from '@bnbarak/reactai/scanner' const scanner = new ComponentScanner () const manifests = scanner . scan ( './src' ) const writer = new ManifestWriter () writer . write ( manifests , './dist' ) Key files File Role src/cli.ts CLI entry \u2014 parses args, runs scanner + writer src/index.ts Programmatic exports src/ComponentScanner.ts ts-morph AST traversal \u2014 extracts manifest data src/SchemaGenerator.ts TypeScript prop types \u2192 JSON Schema src/ManifestWriter.ts Writes registry.json","title":"Scanner"},{"location":"guides/scanner/#when-you-need-it","text":"You only need the scanner if you're using the reactAI() HOC pattern. Components using useStateWithAi() describe themselves at runtime \u2014 they don't need the scanner. Pattern Scanner needed? useStateWithAi() No \u2014 self-describing at runtime reactAI() HOC Yes \u2014 props come from the scanner","title":"When you need it"},{"location":"guides/scanner/#annotating-a-component","text":"Add a @reactAi JSDoc tag to the props interface. The scanner will extract it. /** * @reactAi * @key demo-card * @description A product card showing a title and CTA button. */ interface DemoCardProps { /** @reactAi Headline text */ title : string /** @reactAi Supporting body copy */ body? : string /** @noAI Internal click handler */ onButtonClick : () => void } Rules: - @reactAi on the interface \u2014 marks it for scanning - @key \u2014 the stable identifier used in patches and SSE events - @description \u2014 what the AI sees when deciding which component to update - @reactAi on a prop \u2014 marks it as AI-writable - @noAI on a prop \u2014 explicitly excludes it (optional, self-documenting) - Function props ( () => void ) are never AI-writable, even if annotated","title":"Annotating a component"},{"location":"guides/scanner/#running-the-scanner","text":"npx react-ai-scan <srcDir> <outDir> Add it to your package.json scripts: { \"scripts\" : { \"scan\" : \"react-ai-scan src/ ./registry.json\" } } Run before the server The server throws if registryPath points to a missing file. Make scan a prerequisite of your server start script.","title":"Running the scanner"},{"location":"guides/scanner/#output-registryjson","text":"[ { \"key\" : \"demo-card\" , \"description\" : \"A product card showing a title and CTA button.\" , \"filePath\" : \"src/components/DemoCard.tsx\" , \"aiWritableProps\" : [ \"title\" , \"body\" ], \"propsJsonSchema\" : { \"type\" : \"object\" , \"properties\" : { \"title\" : { \"type\" : \"string\" }, \"body\" : { \"type\" : \"string\" } }, \"required\" : [ \"title\" ] } } ] The JSON Schema is derived from your TypeScript types. string , number , boolean , and union string literals are supported.","title":"Output: registry.json"},{"location":"guides/scanner/#programmatic-api","text":"The scanner also exports a programmatic API for build tool integration: import { ComponentScanner , ManifestWriter } from '@bnbarak/reactai/scanner' const scanner = new ComponentScanner () const manifests = scanner . scan ( './src' ) const writer = new ManifestWriter () writer . write ( manifests , './dist' )","title":"Programmatic API"},{"location":"guides/scanner/#key-files","text":"File Role src/cli.ts CLI entry \u2014 parses args, runs scanner + writer src/index.ts Programmatic exports src/ComponentScanner.ts ts-morph AST traversal \u2014 extracts manifest data src/SchemaGenerator.ts TypeScript prop types \u2192 JSON Schema src/ManifestWriter.ts Writes registry.json","title":"Key files"},{"location":"guides/sdk/","text":"The SDK is the LLM layer. It takes a prompt and a component snapshot, and returns a validated patch for the most relevant component. Design A single Anthropic API call does everything: selects the target component and generates the patch. This is a deliberate choice \u2014 a two-step \"select then generate\" flow would double the latency and split the context, making it harder for the model to reason about prop values while selecting. The model used is claude-haiku-4-5-20251001 \u2014 optimised for fast, structured output tasks. Usage import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) // Pass to createReactAiRouter app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk })) What happens inside updateFromPrompt ( prompt , manifests , mountedSnapshot ) \u2192 CombinedSelector . select ( prompt , manifests , snapshot ) \u2192 one LLM call with tool_use \u2192 returns { key , instanceId , patch } \u2192 RetryValidator . validateWithRetry ( key , patch , manifest ) \u2192 validates patch keys against aiWritableProps \u2192 if invalid : retry with error feedback ( max 2 retries ) \u2192 returns { target , patch , applied , isDone } isDone The SDK returns isDone: true when the task is complete after the current turn, false when it wants the client to send another prompt turn (multi-step navigation). The bridge's ChatPanel loops until isDone is true or max turns is reached. Bring your own model The server depends on AiSdkLike \u2014 not the Anthropic SDK directly. You can implement your own: import type { AiSdkLike } from '@bnbarak/reactai/server' class MyCustomSdk implements AiSdkLike { async updateFromPrompt ( prompt , manifests , mountedSnapshot ) { // your LLM call here return { target : { key : '...' , instanceId : '...' }, patch : { ... }, applied : true } } } app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk : new MyCustomSdk () })) Debugging prompts Set DEBUG=true in your .env to log all LLM prompts to prompts.txt . Useful for understanding model behaviour and tuning descriptions. DEBUG = true npm run demo:server Key files File Role src/ReactAiSdk.ts Main class \u2014 updateFromPrompt() entry point src/CombinedSelector.ts Single LLM call \u2192 { key, instanceId, patch } src/PatchGenerator.ts Standalone patch generation used by retry loop src/RetryValidator.ts Validation + retry loop src/PromptLogger.ts Appends to prompts.txt when DEBUG=true SdkResult interface SdkResult { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean }","title":"Sdk"},{"location":"guides/sdk/#design","text":"A single Anthropic API call does everything: selects the target component and generates the patch. This is a deliberate choice \u2014 a two-step \"select then generate\" flow would double the latency and split the context, making it harder for the model to reason about prop values while selecting. The model used is claude-haiku-4-5-20251001 \u2014 optimised for fast, structured output tasks.","title":"Design"},{"location":"guides/sdk/#usage","text":"import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) // Pass to createReactAiRouter app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk }))","title":"Usage"},{"location":"guides/sdk/#what-happens-inside","text":"updateFromPrompt ( prompt , manifests , mountedSnapshot ) \u2192 CombinedSelector . select ( prompt , manifests , snapshot ) \u2192 one LLM call with tool_use \u2192 returns { key , instanceId , patch } \u2192 RetryValidator . validateWithRetry ( key , patch , manifest ) \u2192 validates patch keys against aiWritableProps \u2192 if invalid : retry with error feedback ( max 2 retries ) \u2192 returns { target , patch , applied , isDone }","title":"What happens inside"},{"location":"guides/sdk/#isdone","text":"The SDK returns isDone: true when the task is complete after the current turn, false when it wants the client to send another prompt turn (multi-step navigation). The bridge's ChatPanel loops until isDone is true or max turns is reached.","title":"isDone"},{"location":"guides/sdk/#bring-your-own-model","text":"The server depends on AiSdkLike \u2014 not the Anthropic SDK directly. You can implement your own: import type { AiSdkLike } from '@bnbarak/reactai/server' class MyCustomSdk implements AiSdkLike { async updateFromPrompt ( prompt , manifests , mountedSnapshot ) { // your LLM call here return { target : { key : '...' , instanceId : '...' }, patch : { ... }, applied : true } } } app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk : new MyCustomSdk () }))","title":"Bring your own model"},{"location":"guides/sdk/#debugging-prompts","text":"Set DEBUG=true in your .env to log all LLM prompts to prompts.txt . Useful for understanding model behaviour and tuning descriptions. DEBUG = true npm run demo:server","title":"Debugging prompts"},{"location":"guides/sdk/#key-files","text":"File Role src/ReactAiSdk.ts Main class \u2014 updateFromPrompt() entry point src/CombinedSelector.ts Single LLM call \u2192 { key, instanceId, patch } src/PatchGenerator.ts Standalone patch generation used by retry loop src/RetryValidator.ts Validation + retry loop src/PromptLogger.ts Appends to prompts.txt when DEBUG=true","title":"Key files"},{"location":"guides/sdk/#sdkresult","text":"interface SdkResult { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean }","title":"SdkResult"},{"location":"guides/server/","text":"The server package is a single Express router. Mount it anywhere in your existing Express app \u2014 it doesn't dictate your app structure. Why a router, not a standalone server Your app already has an Express server. The reactAI server is a guest, not a host. Shipping it as a router means you control CORS, auth middleware, logging, and the mount path. reactAI handles only what it owns: sessions, SSE, patch validation, and AI prompt routing. Setup import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 ) Mount at whatever path you like. The bridge's SessionProvider takes the matching serverUrl . ReactAiRouterOptions Option Type Description registryPath string Path to registry.json . Loaded synchronously at startup \u2014 throws if file is missing. manifests ComponentManifest[] Pass pre-loaded manifests directly instead of a file path. sdk AiSdkLike The LLM SDK instance. Required for AI prompt handling. Omit to disable the /ai/prompt route. Registry is required to start If you pass registryPath and the file doesn't exist, createReactAiRouter throws immediately. Run npm run scan before starting the server. No SDK, no AI route You can run the server without an SDK \u2014 sessions, SSE, and direct patch routes still work. Useful for testing the bridge in isolation. Routes All routes are relative to the mount path. POST / sessions \u2192 { sessionId } GET / registry \u2192 ComponentManifest [] GET / registry /: key \u2192 ComponentManifest POST / patches \u2192 validate + SSE broadcast GET / sse /: sessionId \u2192 SSE stream POST / ai / prompt \u2192 LLM call + SSE broadcast ( requires sdk ) POST /sessions Creates a session. Called once by SessionProvider on mount. // Response \u2014 201 Created { \"sessionId\" : \"550e8400-e29b-...\" } POST /patches Apply a patch directly \u2014 no LLM involved. Useful for testing or deterministic updates from your own code. // Request { \"sessionId\" : \"...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"inst-1\" , \"patch\" : { \"title\" : \"New Title\" } } // Response { \"applied\" : true } Returns 422 if any key in patch is not listed in the component's aiWritableProps . POST /ai/prompt Main AI entry point. The bridge's ChatPanel calls this. // Request { \"sessionId\" : \"...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ] } The server merges snapshot with registry.json (snapshot entries take priority), calls the SDK, then broadcasts the patch via SSE. GET /sse/:sessionId Long-lived SSE connection. The bridge opens this automatically after session creation. Events are newline-delimited JSON: data : { \"type\" : \"patch\" , \"key\" : \"demo-card\" , \"instanceId\" : \"...\" , \"patch\" :{ \"title\" : \"AI Title\" }} AiSdkLike interface The server depends on a single interface \u2014 not on the Anthropic SDK directly. You can pass any object that satisfies it: interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean } > } This makes the server testable with mock SDKs and lets you swap LLM providers without touching the server. Key files File Role src/router.ts createReactAiRouter() \u2014 wires services and sub-routers src/types.ts ReactAiRouterOptions , AiSdkLike src/SessionStore.ts In-memory session set src/SseManager.ts Fan-out SSE broadcast per session src/PatchValidator.ts Validates patch keys against aiWritableProps src/routes/ Individual Express sub-routers","title":"Server"},{"location":"guides/server/#why-a-router-not-a-standalone-server","text":"Your app already has an Express server. The reactAI server is a guest, not a host. Shipping it as a router means you control CORS, auth middleware, logging, and the mount path. reactAI handles only what it owns: sessions, SSE, patch validation, and AI prompt routing.","title":"Why a router, not a standalone server"},{"location":"guides/server/#setup","text":"import express from 'express' import { createReactAiRouter } from '@bnbarak/reactai/server' import { ReactAiSdk } from '@bnbarak/reactai/sdk' import Anthropic from '@anthropic-ai/sdk' const app = express () const sdk = new ReactAiSdk ( new Anthropic ({ apiKey : process.env.ANTHROPIC_API_KEY })) app . use ( '/api' , createReactAiRouter ({ registryPath : './registry.json' , sdk , })) app . listen ( 3001 ) Mount at whatever path you like. The bridge's SessionProvider takes the matching serverUrl .","title":"Setup"},{"location":"guides/server/#reactairouteroptions","text":"Option Type Description registryPath string Path to registry.json . Loaded synchronously at startup \u2014 throws if file is missing. manifests ComponentManifest[] Pass pre-loaded manifests directly instead of a file path. sdk AiSdkLike The LLM SDK instance. Required for AI prompt handling. Omit to disable the /ai/prompt route. Registry is required to start If you pass registryPath and the file doesn't exist, createReactAiRouter throws immediately. Run npm run scan before starting the server. No SDK, no AI route You can run the server without an SDK \u2014 sessions, SSE, and direct patch routes still work. Useful for testing the bridge in isolation.","title":"ReactAiRouterOptions"},{"location":"guides/server/#routes","text":"All routes are relative to the mount path. POST / sessions \u2192 { sessionId } GET / registry \u2192 ComponentManifest [] GET / registry /: key \u2192 ComponentManifest POST / patches \u2192 validate + SSE broadcast GET / sse /: sessionId \u2192 SSE stream POST / ai / prompt \u2192 LLM call + SSE broadcast ( requires sdk )","title":"Routes"},{"location":"guides/server/#post-sessions","text":"Creates a session. Called once by SessionProvider on mount. // Response \u2014 201 Created { \"sessionId\" : \"550e8400-e29b-...\" }","title":"POST /sessions"},{"location":"guides/server/#post-patches","text":"Apply a patch directly \u2014 no LLM involved. Useful for testing or deterministic updates from your own code. // Request { \"sessionId\" : \"...\" , \"key\" : \"demo-card\" , \"instanceId\" : \"inst-1\" , \"patch\" : { \"title\" : \"New Title\" } } // Response { \"applied\" : true } Returns 422 if any key in patch is not listed in the component's aiWritableProps .","title":"POST /patches"},{"location":"guides/server/#post-aiprompt","text":"Main AI entry point. The bridge's ChatPanel calls this. // Request { \"sessionId\" : \"...\" , \"prompt\" : \"Change the username to alice\" , \"snapshot\" : [ { \"key\" : \"user-profile-settings\" , \"instanceId\" : \"user-profile-settings\" , \"description\" : \"User profile settings\" , \"aiWritableProps\" : [ \"username\" , \"language\" ], \"currentProps\" : { \"username\" : \"barak\" , \"language\" : \"English\" }, \"context\" : { \"language\" : [ \"English\" , \"Hebrew\" , \"Spanish\" ] } } ] } The server merges snapshot with registry.json (snapshot entries take priority), calls the SDK, then broadcasts the patch via SSE.","title":"POST /ai/prompt"},{"location":"guides/server/#get-ssesessionid","text":"Long-lived SSE connection. The bridge opens this automatically after session creation. Events are newline-delimited JSON: data : { \"type\" : \"patch\" , \"key\" : \"demo-card\" , \"instanceId\" : \"...\" , \"patch\" :{ \"title\" : \"AI Title\" }}","title":"GET /sse/:sessionId"},{"location":"guides/server/#aisdklike-interface","text":"The server depends on a single interface \u2014 not on the Anthropic SDK directly. You can pass any object that satisfies it: interface AiSdkLike { updateFromPrompt ( prompt : string , manifests : ComponentManifest [], mountedSnapshot : MountedInstance [], accessibilityTree? : string , markers? : Record < string , unknown > , currentUrl? : string , ) : Promise < { target : { key : string ; instanceId : string } | null patch : Record < string , unknown > | null applied : boolean errors? : string [] isDone? : boolean } > } This makes the server testable with mock SDKs and lets you swap LLM providers without touching the server.","title":"AiSdkLike interface"},{"location":"guides/server/#key-files","text":"File Role src/router.ts createReactAiRouter() \u2014 wires services and sub-routers src/types.ts ReactAiRouterOptions , AiSdkLike src/SessionStore.ts In-memory session set src/SseManager.ts Fan-out SSE broadcast per session src/PatchValidator.ts Validates patch keys against aiWritableProps src/routes/ Individual Express sub-routers","title":"Key files"}]}